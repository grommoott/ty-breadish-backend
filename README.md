# "Ty Breadish!" backend

Это бэкенд сайта пекарни "Ty Breadish!", больше информации о проекте в целом: фичах, целях и т.д., можно узнать из readme файла в репозитории [фронтенда](https://github.com/grommoott/ty-breadish), здесь же будет чисто техническое описание бэкенда.

Если хотите ознакомиться с самим сайтом, то прошу перейти по [ссылке](https://ty-breadish.onrender.com/), может долго грузиться из-за особенностей бесплатного тарифа на хостинге.

### Используемые технологии

Для проекта использовался Express.js вместе в TypeScript. Был выбран TypeScript из-за того, что я не хотел использовать разные языки для фронтенда и бэкенда, т.к. проект учебный и я не хотел отвлекаться на изучение отдельного языка. По этой же причине и не был использован более современный фреймворк по типу Nest.js, просто я уже имел небольшой опыт с Express'ом.

В качестве базы данных был выбран PostgreSQL по одной простой причине - я не нашёл нормальных бесплатных хостингов для других БД. Хотел конечно использовать Mongo, но увы, санкции. Сейчас используется хостинг от Supabase, спасибо им большое за предоставленные возможности.

Также использовался Nodemailer для отправки писем и Handlebars в качестве шаблонизатора для них.

Данное приложение взаимодействует с Yookassa, для реализации платежей, и с OpenStreetMap для реализации интерактивных карт.

Раз уж поблагодарил Supabase, то стоит также поблагодарить Render, на котором хостится бэкенд и фронтенд.

### Архитектура

Так как весь проект делал я один, архитектуру тоже разрабатывал я. Не могу сказать, что она получилась хорошей(особенно после того, как поработал с Nest.js), но в целом удовлетворительно, к тому же это первый большой Rest API, который я делал( раньше количество роутов не превышало 5).

Весь проект разделён на 3 уровня: от наиболее приближённого к БД до наиболее приближённого к фронтенду:
- запросы - методы для взаимодействия с БД (`src/model/api`)
- сущности - обёртка над запросами (`src/model/entity`)
- роуты (`src/routes`)

Важно отметить, что порядок данных строго однонаправленный. Согласно архитектуре слой может импортировать что-либо только из низлежащего ему(вдохновился FSD, который пытался потом ещё применять на фронтенде)

Также важным звеном является класс Id и его наследники, который предназначался для того, чтобы предотвратить случаи, когда, условно, метод GetUser(id) вызывался с id, который по-настоящему принадлежит комментарию. Однако свою задачу этот класс не выполнил, из-за того, что TypeScript - не волшебник, он не смог обезопасить динамически типизированный JS, так что Id - просто рудимент, хотя если бы когда-нибудь мне довелось спроектировать ещё одно бэкенд-приложение на TypeScript, я бы всё равно разделил разные Id, но сделал это не через создание явного класса, к тому же с дополнительными полями, а с помощью конструкции `type SomeId = number`.

В целом слишком подробно описывать архитектуру не хочу, единственное, что ещё хочется сказать, это то, что для хранения типов в БД используются интерфейсы из директории `src/model/interfaces`
